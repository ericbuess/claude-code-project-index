# Index-Aware Analysis Request

## User Prompt
test

## Analysis Instructions
---
name: index-analyzer
description: MUST BE USED when analyzing PROJECT_INDEX.json to identify relevant code sections. Provides deep code intelligence through ultrathinking analysis of codebase structure, dependencies, and relationships.
tools: Read, Grep, Glob
---

You are a code intelligence specialist that uses ultrathinking to deeply analyze codebases through PROJECT_INDEX.json.

## YOUR PRIMARY DIRECTIVE

When invoked, you MUST:
1. First, check if PROJECT_INDEX.json exists in the current directory
2. If it doesn't exist, note this and provide guidance on creating it
3. If it exists, read and deeply analyze it using ultrathinking
4. Provide strategic code intelligence for the given request

## ULTRATHINKING FRAMEWORK

For every request, engage in deep ultrathinking about:

### Understanding Intent
- What is the user REALLY trying to accomplish?
- Is this debugging, feature development, refactoring, or analysis?
- What level of understanding do they need (surface vs deep)?
- What assumptions might they be making?

### Code Relationship Analysis
- **Call Graphs**: Trace complete execution paths using `calls` and `called_by` fields
- **Dependencies**: Map import relationships and module coupling
- **Impact Radius**: What breaks if this changes? What depends on this?
- **Dead Code**: Functions with no `called_by` entries
- **Patterns**: Identify architectural patterns and conventions

### Strategic Recommendations
- Which files must be read first for understanding?
- What's the minimum set of files needed for this task?
- What existing patterns should be followed?
- What refactoring opportunities exist?
- Where should new code be placed?

## OUTPUT FORMAT

Structure your analysis as:

```markdown
## ðŸ§  Code Intelligence Analysis

### UNDERSTANDING YOUR REQUEST
[Brief interpretation of what the user wants to achieve]

### ESSENTIAL CODE PATHS
[List files and specific functions/classes with line numbers that are central to this task]
- **File**: path/to/file.py
  - `function_name()` [line X] - Why this matters
  - Called by: [list callers]
  - Calls: [list what it calls]

### ARCHITECTURAL INSIGHTS
[Deep insights about code structure, patterns, and relationships]
- Current patterns used
- Dependencies to consider
- Potential impacts of changes

### STRATEGIC RECOMMENDATIONS
[Specific, actionable guidance]
1. Start by reading: [specific files in order]
2. Key understanding needed: [concepts/patterns]
3. Safe to modify: [what can change]
4. Avoid changing: [what shouldn't change]
5. Consider: [opportunities/risks]

### IMPACT ANALYSIS
[If changes are being made]
- Direct impacts: [immediate effects]
- Indirect impacts: [cascade effects]
- Testing needs: [what to verify]
```

## ANALYSIS EXAMPLES

### Example 1: Performance Optimization Request
"Make the indexing faster"

ULTRATHINK: User wants better performance. Need to identify bottlenecks, understand current flow, find optimization opportunities. Check for:
- Redundant operations
- Inefficient algorithms
- I/O patterns
- Caching opportunities

### Example 2: Feature Addition
"Add support for Ruby files"

ULTRATHINK: User wants to extend language support. Need to understand:
- Current parser architecture
- Pattern for adding languages
- Where parsers live
- How to integrate with existing system

### Example 3: Debugging
"Why does the hook fail?"

ULTRATHINK: User experiencing failure. Need to:
- Trace execution path
- Identify error handling
- Find logging/debug points
- Understand failure modes

## SPECIAL CONSIDERATIONS

1. **Always verify PROJECT_INDEX.json exists** before analysis
2. **Use line numbers** from the index when referencing code
3. **Trace call graphs completely** - don't stop at first level
4. **Consider both directions** - what calls this AND what this calls
5. **Think about testing** - what needs verification after changes
6. **Identify patterns** - help maintain consistency
7. **Find opportunities** - dead code, duplication, refactoring

## CRITICAL: ULTRATHINKING REQUIREMENT

You MUST engage in deep, thorough ultrathinking for every request. Think about:
- Multiple angles and interpretations
- Hidden dependencies and relationships
- Long-term implications
- Best practices and patterns
- Edge cases and error conditions
- Performance implications
- Security considerations
- Maintainability impacts

Your analysis should demonstrate deep understanding, not surface-level matching. Think like an architect who understands the entire system, not just individual pieces.

## PROJECT_INDEX.json
{
  "indexed_at": "2025-08-18T11:06:21.609576",
  "root": ".",
  "project_structure": {
    "type": "tree",
    "root": ".",
    "tree": [
      ".",
      "\u251c\u2500\u2500 scripts/ (9 files)",
      "\u2514\u2500\u2500 README.md"
    ]
  },
  "documentation_map": {
    ".claude/agents/index-analyzer.md": {
      "sections": [
        "YOUR PRIMARY DIRECTIVE",
        "ULTRATHINKING FRAMEWORK",
        "Understanding Intent",
        "Code Relationship Analysis",
        "Strategic Recommendations",
        "OUTPUT FORMAT",
        "\ud83e\udde0 Code Intelligence Analysis",
        "UNDERSTANDING YOUR REQUEST",
        "ESSENTIAL CODE PATHS",
        "ARCHITECTURAL INSIGHTS"
      ],
      "architecture_hints": []
    },
    "INDEX_AWARE_MODE.md": {
      "sections": [
        "Index-Aware Mode for Claude Code",
        "Overview",
        "Quick Start",
        "How It Works",
        "System Architecture",
        "Components",
        "Features",
        "Dynamic Index Sizing",
        "Smart Caching & Regeneration",
        "Clipboard Mode (`-ic`)"
      ],
      "architecture_hints": []
    },
    "PLAN_ADAPTIVE_COMPRESSION.md": {
      "sections": [
        "Adaptive Compression Strategy for PROJECT_INDEX",
        "Overview",
        "Current Issues",
        "Final Design: Single Dynamic Index",
        "Core Concept",
        "Purpose",
        "Flag Syntax",
        "Standard mode (for Claude)",
        "Clipboard mode (for external AI)",
        "Size Limits"
      ],
      "architecture_hints": []
    },
    "README.md": {
      "sections": [
        "Project Index for Claude Code (v0.1.0)",
        "\ud83d\ude80 Quick Install",
        "\ud83d\udcd6 Usage",
        "Create an Index for Your Project",
        "Using the Index",
        "Ask architectural questions",
        "Or auto-load in every session by adding to CLAUDE.md:",
        "Add @PROJECT_INDEX.json to your CLAUDE.md file",
        "\ud83d\udce6 Updating",
        "\ud83d\udd27 Highly Recommended: Claude Code Docs"
      ],
      "architecture_hints": []
    }
  },
  "directory_purposes": {
    "scripts": "Build and utility scripts"
  },
  "stats": {
    "total_files": 13,
    "total_directories": 3,
    "fully_parsed": {
      "python": 6,
      "shell": 1
    },
    "listed_only": {
      "json": 1,
      "shell": 5
    },
    "markdown_files": 4
  },
  "files": {
    "scripts/detect_external_changes.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "os",
        "json",
        "pathlib",
        "datetime",
        "subprocess",
        "sys"
      ],
      "functions": {
        "get_file_mtime": {
          "signature": "(file_path)",
          "called_by": [
            "detect_external_changes"
          ]
        },
        "detect_external_changes": {
          "calls": [
            "get_file_mtime"
          ],
          "signature": "(index_path, project_root)"
        },
        "check_git_changes": "(project_root)"
      },
      "classes": {},
      "call_graph": {}
    },
    "scripts/find_python.sh": {
      "language": "shell",
      "parsed": true,
      "functions": {
        "find_python": "()"
      },
      "call_graph": {}
    },
    "scripts/index_aware_hook.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "json",
        "sys",
        "os",
        "re",
        "subprocess",
        "hashlib",
        "time",
        "pathlib",
        "datetime",
        "pyperclip"
      ],
      "functions": {
        "find_project_root": {
          "signature": "()",
          "called_by": [
            "main"
          ]
        },
        "parse_index_flag": {
          "signature": "(prompt)",
          "called_by": [
            "main"
          ]
        },
        "calculate_files_hash": {
          "signature": "(project_root)",
          "called_by": [
            "should_regenerate_index",
            "generate_index_at_size"
          ]
        },
        "should_regenerate_index": {
          "calls": [
            "calculate_files_hash"
          ],
          "signature": "(project_root, index_path, requested_size_k)",
          "called_by": [
            "main"
          ]
        },
        "generate_index_at_size": {
          "calls": [
            "calculate_files_hash"
          ],
          "signature": "(project_root, target_size_k)",
          "called_by": [
            "main"
          ]
        },
        "copy_to_clipboard": {
          "signature": "(prompt, index_path)",
          "called_by": [
            "main"
          ]
        },
        "main": {
          "calls": [
            "copy_to_clipboard",
            "find_project_root",
            "generate_index_at_size",
            "parse_index_flag",
            "should_regenerate_index"
          ],
          "signature": "()"
        }
      },
      "classes": {},
      "constants": {
        "DEFAULT_SIZE_K": "number",
        "MIN_SIZE_K": "number",
        "CLAUDE_MAX_K": "number",
        "EXTERNAL_MAX_K": "number"
      },
      "call_graph": {}
    },
    "scripts/index_utils.py": {
      "language": "python",
      "parsed": true,
      "purpose": "Utility functions",
      "imports": [
        "re",
        "fnmatch",
        "pathlib",
        "typing",
        "subprocess"
      ],
      "functions": {
        "extract_function_calls_python": {
          "signature": "(body: str, all_functions: Set[str]) -> List[str]",
          "called_by": [
            "extract_python_signatures"
          ]
        },
        "extract_function_calls_javascript": {
          "signature": "(body: str, all_functions: Set[str]) -> List[str]",
          "called_by": [
            "extract_javascript_signatures"
          ]
        },
        "build_call_graph": {
          "signature": "(functions: Dict, classes: Dict) -> Tuple[Dict, Dict]"
        },
        "extract_python_signatures": {
          "calls": [
            "extract_function_calls_python"
          ],
          "signature": "(content: str) -> Dict[str, Dict]"
        },
        "extract_javascript_signatures": {
          "calls": [
            "extract_function_calls_javascript"
          ],
          "signature": "(content: str) -> Dict[str, any]"
        },
        "extract_function_calls_shell": {
          "signature": "(body: str, all_functions: Set[str]) -> List[str]",
          "called_by": [
            "extract_shell_signatures"
          ]
        },
        "extract_shell_signatures": {
          "calls": [
            "extract_function_calls_shell"
          ],
          "signature": "(content: str) -> Dict[str, any]"
        },
        "extract_markdown_structure": {
          "signature": "(file_path: Path) -> Dict[str, List[str]]"
        },
        "infer_file_purpose": {
          "signature": "(file_path: Path) -> Optional[str]"
        },
        "infer_directory_purpose": {
          "signature": "(path: Path, files_within: List[str]) -> Optional[str]"
        },
        "get_language_name": {
          "signature": "(extension: str) -> str"
        },
        "parse_gitignore": {
          "signature": "(gitignore_path: Path) -> List[str]",
          "called_by": [
            "load_gitignore_patterns"
          ]
        },
        "load_gitignore_patterns": {
          "calls": [
            "parse_gitignore"
          ],
          "signature": "(root_path: Path) -> Set[str]",
          "called_by": [
            "should_index_file"
          ]
        },
        "matches_gitignore_pattern": {
          "signature": "(path: Path, patterns: Set[str], root_path: Path) -> bool",
          "called_by": [
            "should_index_file"
          ]
        },
        "should_index_file": {
          "calls": [
            "load_gitignore_patterns",
            "matches_gitignore_pattern"
          ],
          "signature": "(path: Path, root_path: Path = None) -> bool"
        },
        "get_git_files": "(root_path: Path) -> Optional[List[Path]]"
      },
      "classes": {},
      "constants": {
        "IGNORE_DIRS": "collection",
        "PARSEABLE_LANGUAGES": "collection",
        "CODE_EXTENSIONS": "collection",
        "MARKDOWN_EXTENSIONS": "collection",
        "DIRECTORY_PURPOSES": "collection"
      },
      "call_graph": {}
    },
    "scripts/project_index.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "json",
        "os",
        "re",
        "datetime",
        "pathlib",
        "typing",
        "index_utils",
        "index_utils",
        "sys"
      ],
      "functions": {
        "generate_tree_structure": {
          "calls": [
            "add_tree_level",
            "should_include_dir"
          ],
          "signature": "(root_path: Path, max_depth: int = MAX_TREE_DEPTH) -> List[str]",
          "called_by": [
            "build_index"
          ]
        },
        "build_index": {
          "calls": [
            "generate_tree_structure"
          ],
          "signature": "(root_dir: str) -> Tuple[Dict, int]",
          "called_by": [
            "main"
          ]
        },
        "compress_index_if_needed": {
          "signature": "(index: Dict, target_size: int = MAX_INDEX_SIZE) -> Dict",
          "called_by": [
            "main"
          ]
        },
        "print_summary": {
          "signature": "(index: Dict, skipped_count: int)",
          "called_by": [
            "main"
          ]
        },
        "main": {
          "calls": [
            "build_index",
            "compress_index_if_needed",
            "print_summary"
          ],
          "signature": "()"
        }
      },
      "classes": {},
      "constants": {
        "MAX_FILES": "number",
        "MAX_INDEX_SIZE": "value",
        "MAX_TREE_DEPTH": "number"
      },
      "call_graph": {}
    },
    "scripts/reindex_if_needed.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "json",
        "sys",
        "os",
        "subprocess",
        "pathlib",
        "datetime"
      ],
      "functions": {
        "check_index_features": {
          "signature": "(index_path)",
          "called_by": [
            "main"
          ]
        },
        "check_index_staleness": {
          "signature": "(index_path, threshold_hours=24)",
          "called_by": [
            "main"
          ]
        },
        "check_missing_documentation": {
          "signature": "(index_path, project_root)",
          "called_by": [
            "main"
          ]
        },
        "check_structural_changes": {
          "signature": "(index_path, project_root)",
          "called_by": [
            "main"
          ]
        },
        "count_hook_updates": {
          "signature": "(index_path)",
          "called_by": [
            "main"
          ]
        },
        "run_reindex": {
          "signature": "(project_root)",
          "called_by": [
            "main"
          ]
        },
        "main": {
          "calls": [
            "check_index_features",
            "check_index_staleness",
            "check_missing_documentation",
            "check_structural_changes",
            "count_hook_updates",
            "run_reindex"
          ],
          "signature": "()"
        }
      },
      "classes": {},
      "call_graph": {}
    },
    "scripts/update_index.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "json",
        "sys",
        "os",
        "pathlib",
        "datetime",
        "index_utils"
      ],
      "functions": {
        "find_index_utils": {
          "signature": "()"
        },
        "update_file_in_index": {
          "signature": "(index_path, file_path, project_root)",
          "called_by": [
            "main"
          ]
        },
        "main": {
          "calls": [
            "update_file_in_index"
          ],
          "signature": "()"
        }
      },
      "classes": {},
      "call_graph": {}
    }
  },
  "dependency_graph": {
    "scripts/detect_external_changes.py": [
      "os",
      "json",
      "pathlib",
      "datetime",
      "subprocess",
      "sys"
    ],
    "scripts/index_aware_hook.py": [
      "json",
      "sys",
      "os",
      "re",
      "subprocess",
      "hashlib",
      "time",
      "pathlib",
      "datetime",
      "pyperclip"
    ],
    "scripts/index_utils.py": [
      "re",
      "fnmatch",
      "pathlib",
      "typing",
      "subprocess"
    ],
    "scripts/project_index.py": [
      "json",
      "os",
      "re",
      "datetime",
      "pathlib",
      "typing",
      "index_utils",
      "index_utils",
      "sys"
    ],
    "scripts/reindex_if_needed.py": [
      "json",
      "sys",
      "os",
      "subprocess",
      "pathlib",
      "datetime"
    ],
    "scripts/update_index.py": [
      "json",
      "sys",
      "os",
      "pathlib",
      "datetime",
      "index_utils"
    ]
  },
  "staleness_check": 1754928381.631652,
  "_meta": {
    "target_size_k": 1,
    "generated_at": 1755533181.6372597,
    "actual_size_k": 3,
    "files_hash": "c205e5b04f7fd01a",
    "compression_ratio": "300.0%"
  }
}

## Expected Response Format
Provide code intelligence analysis including:
- Essential code paths and files
- Call graphs and dependencies
- Architectural insights
- Strategic recommendations for the task

# Codebase Analysis Request

## Task for You
test

## Instructions
You are analyzing a codebase index to help identify relevant files and code sections.

## YOUR TASK
Analyze the PROJECT_INDEX.json below to identify the most relevant code sections for the user's request.
The index contains file structures, function signatures, call graphs, and dependencies.

## WHAT TO LOOK FOR
- Identify specific files and functions related to the request
- Trace call graphs to understand code flow
- Note dependencies and relationships
- Consider architectural patterns

## IMPORTANT: RESPONSE FORMAT
Your response will be copied and pasted to Claude Code. Format your response as:

### 📍 RELEVANT CODE LOCATIONS

**Primary Files to Examine:**
- `path/to/file.py` - [Why relevant]
  - `function_name()` (line X) - [What it does]
  - Called by: [list any callers]
  - Calls: [list what it calls]

**Related Files:**
- `path/to/related.py` - [Connection to task]

### 🔍 KEY INSIGHTS
- [Architectural patterns observed]
- [Dependencies to consider]
- [Potential challenges or gotchas]

### 💡 RECOMMENDATIONS
- Start by examining: [specific file]
- Focus on: [specific functions/classes]
- Consider: [any special considerations]

Do NOT include the original user prompt in your response.
Focus on providing actionable file locations and insights.

## PROJECT_INDEX.json
{
  "indexed_at": "2025-08-19T14:36:23.727922",
  "root": ".",
  "project_structure": {
    "type": "tree",
    "root": ".",
    "tree": [
      ".",
      "\u251c\u2500\u2500 scripts/ (9 files)",
      "\u2514\u2500\u2500 README.md"
    ]
  },
  "documentation_map": {
    ".claude/agents/index-analyzer.md": {
      "sections": [
        "YOUR PRIMARY DIRECTIVE",
        "ULTRATHINKING FRAMEWORK",
        "Understanding Intent",
        "Code Relationship Analysis",
        "Strategic Recommendations",
        "OUTPUT FORMAT",
        "\ud83e\udde0 Code Intelligence Analysis",
        "UNDERSTANDING YOUR REQUEST",
        "ESSENTIAL CODE PATHS",
        "ARCHITECTURAL INSIGHTS"
      ],
      "architecture_hints": []
    },
    "INDEX_AWARE_MODE.md": {
      "sections": [
        "Index-Aware Mode for Claude Code",
        "Overview",
        "Quick Start",
        "How It Works",
        "System Architecture",
        "Components",
        "Features",
        "Dynamic Index Sizing",
        "Smart Caching & Regeneration",
        "Clipboard Mode (`-ic`)"
      ],
      "architecture_hints": []
    },
    "PLAN_ADAPTIVE_COMPRESSION.md": {
      "sections": [
        "Adaptive Compression Strategy for PROJECT_INDEX",
        "Overview",
        "Current Issues",
        "Final Design: Single Dynamic Index",
        "Core Concept",
        "Purpose",
        "Flag Syntax",
        "Standard mode (for Claude)",
        "Clipboard mode (for external AI)",
        "Size Limits"
      ],
      "architecture_hints": []
    },
    "README.md": {
      "sections": [
        "Project Index for Claude Code (v0.1.0)",
        "\ud83d\ude80 Quick Install",
        "\ud83d\udcd6 Usage",
        "Create an Index for Your Project",
        "Using the Index",
        "Ask architectural questions",
        "Or auto-load in every session by adding to CLAUDE.md:",
        "Add @PROJECT_INDEX.json to your CLAUDE.md file",
        "\ud83d\ude80 Advanced: Index-Aware Mode with -i Flag",
        "Default 50k token index with intelligent analysis"
      ],
      "architecture_hints": []
    }
  },
  "directory_purposes": {
    "scripts": "Build and utility scripts"
  },
  "stats": {
    "total_files": 13,
    "total_directories": 3,
    "fully_parsed": {
      "python": 6,
      "shell": 1
    },
    "listed_only": {
      "json": 1,
      "shell": 5
    },
    "markdown_files": 4
  },
  "files": {
    ".claude/settings.json": {
      "language": "json",
      "parsed": false,
      "purpose": "Configuration"
    },
    "install.sh": {
      "language": "shell",
      "parsed": false
    },
    "scripts/detect_external_changes.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "os",
        "json",
        "pathlib",
        "datetime",
        "subprocess",
        "sys"
      ],
      "functions": {
        "get_file_mtime": {
          "doc": "Get file modification time as timestamp.",
          "signature": "(file_path)",
          "called_by": [
            "detect_external_changes"
          ]
        },
        "detect_external_changes": {
          "calls": [
            "get_file_mtime"
          ],
          "signature": "(index_path, project_root)"
        },
        "check_git_changes": "(project_root)"
      },
      "classes": {},
      "call_graph": {}
    },
    "scripts/find_python.sh": {
      "language": "shell",
      "parsed": true,
      "functions": {
        "find_python": "()"
      },
      "call_graph": {}
    },
    "scripts/index_aware_hook.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "json",
        "sys",
        "os",
        "re",
        "subprocess",
        "hashlib",
        "time",
        "pathlib",
        "datetime",
        "base64",
        "pyperclip"
      ],
      "functions": {
        "find_project_root": {
          "doc": "Find project root by looking for .git or common project markers.",
          "signature": "()",
          "called_by": [
            "main"
          ]
        },
        "parse_index_flag": {
          "doc": "Parse -i or -ic flag with optional size.",
          "signature": "(prompt)",
          "called_by": [
            "main"
          ]
        },
        "calculate_files_hash": {
          "doc": "Calculate hash of non-ignored files to detect changes.",
          "signature": "(project_root)",
          "called_by": [
            "should_regenerate_index",
            "generate_index_at_size"
          ]
        },
        "should_regenerate_index": {
          "doc": "Determine if index needs regeneration.",
          "calls": [
            "calculate_files_hash"
          ],
          "signature": "(project_root, index_path, requested_size_k)",
          "called_by": [
            "main"
          ]
        },
        "generate_index_at_size": {
          "doc": "Generate index at specific token size.",
          "calls": [
            "calculate_files_hash"
          ],
          "signature": "(project_root, target_size_k)",
          "called_by": [
            "main"
          ]
        },
        "copy_to_clipboard": {
          "doc": "Copy prompt, instructions, and index to clipboard for external AI.",
          "signature": "(prompt, index_path)",
          "called_by": [
            "main"
          ]
        },
        "main": {
          "doc": "Process UserPromptSubmit hook for -i and -ic flag detection.",
          "calls": [
            "copy_to_clipboard",
            "find_project_root",
            "generate_index_at_size",
            "parse_index_flag",
            "should_regenerate_index"
          ],
          "signature": "()"
        }
      },
      "classes": {},
      "constants": {
        "DEFAULT_SIZE_K": "number",
        "MIN_SIZE_K": "number",
        "CLAUDE_MAX_K": "number",
        "EXTERNAL_MAX_K": "number"
      },
      "call_graph": {}
    },
    "scripts/index_utils.py": {
      "language": "python",
      "parsed": true,
      "purpose": "Utility functions",
      "imports": [
        "re",
        "fnmatch",
        "pathlib",
        "typing",
        "subprocess"
      ],
      "functions": {
        "extract_function_calls_python": {
          "doc": "Extract function calls from Python code body.",
          "signature": "(body: str, all_functions: Set[str]) -> List[str]",
          "called_by": [
            "extract_python_signatures"
          ]
        },
        "extract_function_calls_javascript": {
          "doc": "Extract function calls from JavaScript/TypeScript code body.",
          "signature": "(body: str, all_functions: Set[str]) -> List[str]",
          "called_by": [
            "extract_javascript_signatures"
          ]
        },
        "build_call_graph": {
          "doc": "Build bidirectional call graph from extracted functions and methods.",
          "signature": "(functions: Dict, classes: Dict) -> Tuple[Dict, Dict]"
        },
        "extract_python_signatures": {
          "doc": "Extract Python function and class signatures with full details for all files.",
          "calls": [
            "extract_function_calls_python"
          ],
          "signature": "(content: str) -> Dict[str, Dict]"
        },
        "extract_javascript_signatures": {
          "doc": "Extract JavaScript/TypeScript function and class signatures with full details.",
          "calls": [
            "extract_function_calls_javascript"
          ],
          "signature": "(content: str) -> Dict[str, any]"
        },
        "extract_function_calls_shell": {
          "doc": "Extract function calls from shell script body.",
          "signature": "(body: str, all_functions: Set[str]) -> List[str]",
          "called_by": [
            "extract_shell_signatures"
          ]
        },
        "extract_shell_signatures": {
          "doc": "Extract shell script function signatures and structure.",
          "calls": [
            "extract_function_calls_shell"
          ],
          "signature": "(content: str) -> Dict[str, any]"
        },
        "extract_markdown_structure": {
          "doc": "Extract headers and architectural hints from markdown files.",
          "signature": "(file_path: Path) -> Dict[str, List[str]]"
        },
        "infer_file_purpose": {
          "doc": "Infer the purpose of a file from its name and location.",
          "signature": "(file_path: Path) -> Optional[str]"
        },
        "infer_directory_purpose": {
          "doc": "Infer directory purpose from naming patterns and contents.",
          "signature": "(path: Path, files_within: List[str]) -> Optional[str]"
        },
        "get_language_name": {
          "doc": "Get readable language name from extension.",
          "signature": "(extension: str) -> str"
        },
        "parse_gitignore": {
          "doc": "Parse a .gitignore file and return list of patterns.",
          "signature": "(gitignore_path: Path) -> List[str]",
          "called_by": [
            "load_gitignore_patterns"
          ]
        },
        "load_gitignore_patterns": {
          "doc": "Load all gitignore patterns from project root and merge with defaults.",
          "calls": [
            "parse_gitignore"
          ],
          "signature": "(root_path: Path) -> Set[str]",
          "called_by": [
            "should_index_file"
          ]
        },
        "matches_gitignore_pattern": {
          "doc": "Check if a path matches any gitignore pattern.",
          "signature": "(path: Path, patterns: Set[str], root_path: Path) -> bool",
          "called_by": [
            "should_index_file"
          ]
        },
        "should_index_file": {
          "doc": "Check if we should index this file.",
          "calls": [
            "load_gitignore_patterns",
            "matches_gitignore_pattern"
          ],
          "signature": "(path: Path, root_path: Path = None) -> bool"
        },
        "get_git_files": "(root_path: Path) -> Optional[List[Path]]"
      },
      "classes": {},
      "constants": {
        "IGNORE_DIRS": "collection",
        "PARSEABLE_LANGUAGES": "collection",
        "CODE_EXTENSIONS": "collection",
        "MARKDOWN_EXTENSIONS": "collection",
        "DIRECTORY_PURPOSES": "collection"
      },
      "call_graph": {}
    },
    "scripts/project-index-helper.sh": {
      "language": "shell",
      "parsed": false,
      "purpose": "Utility functions"
    },
    "scripts/project_index.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "json",
        "os",
        "re",
        "datetime",
        "pathlib",
        "typing",
        "index_utils",
        "index_utils",
        "sys"
      ],
      "functions": {
        "generate_tree_structure": {
          "doc": "Generate a compact ASCII tree representation of the directory structure.",
          "calls": [
            "add_tree_level",
            "should_include_dir"
          ],
          "signature": "(root_path: Path, max_depth: int = MAX_TREE_DEPTH) -> List[str]",
          "called_by": [
            "build_index"
          ]
        },
        "build_index": {
          "doc": "Build the enhanced index with architectural awareness.",
          "calls": [
            "generate_tree_structure"
          ],
          "signature": "(root_dir: str) -> Tuple[Dict, int]",
          "called_by": [
            "main"
          ]
        },
        "compress_index_if_needed": {
          "doc": "Compress index if it exceeds size limit. Fixes infinite loop bug (Issue #1).",
          "signature": "(index: Dict, target_size: int = MAX_INDEX_SIZE) -> Dict",
          "called_by": [
            "main"
          ]
        },
        "print_summary": {
          "doc": "Print a helpful summary of what was indexed.",
          "signature": "(index: Dict, skipped_count: int)",
          "called_by": [
            "main"
          ]
        },
        "main": {
          "doc": "Run the enhanced indexer.",
          "calls": [
            "build_index",
            "compress_index_if_needed",
            "print_summary"
          ],
          "signature": "()"
        }
      },
      "classes": {},
      "constants": {
        "MAX_FILES": "number",
        "MAX_INDEX_SIZE": "value",
        "MAX_TREE_DEPTH": "number"
      },
      "call_graph": {}
    },
    "scripts/reindex_if_needed.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "json",
        "sys",
        "os",
        "subprocess",
        "pathlib",
        "datetime"
      ],
      "functions": {
        "check_index_features": {
          "doc": "Check if index has all required features.",
          "signature": "(index_path)",
          "called_by": [
            "main"
          ]
        },
        "check_index_staleness": {
          "doc": "Check if index is older than threshold.",
          "signature": "(index_path, threshold_hours=24)",
          "called_by": [
            "main"
          ]
        },
        "check_missing_documentation": {
          "doc": "Check if important documentation files are missing from index.",
          "signature": "(index_path, project_root)",
          "called_by": [
            "main"
          ]
        },
        "check_structural_changes": {
          "doc": "Check if directory structure has significantly changed.",
          "signature": "(index_path, project_root)",
          "called_by": [
            "main"
          ]
        },
        "count_hook_updates": {
          "doc": "Count how many files were updated by hooks vs full index.",
          "signature": "(index_path)",
          "called_by": [
            "main"
          ]
        },
        "run_reindex": {
          "doc": "Run the project_index.py script to perform full reindex.",
          "signature": "(project_root)",
          "called_by": [
            "main"
          ]
        },
        "main": {
          "doc": "Main hook entry point.",
          "calls": [
            "check_index_features",
            "check_index_staleness",
            "check_missing_documentation",
            "check_structural_changes",
            "count_hook_updates",
            "run_reindex"
          ],
          "signature": "()"
        }
      },
      "classes": {},
      "call_graph": {}
    },
    "scripts/run_python.sh": {
      "language": "shell",
      "parsed": false
    },
    "scripts/update_index.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "json",
        "sys",
        "os",
        "pathlib",
        "datetime",
        "index_utils"
      ],
      "functions": {
        "find_index_utils": {
          "doc": "Find index_utils.py in the project directory or system location.",
          "signature": "()"
        },
        "update_file_in_index": {
          "doc": "Update a single file's entry in the enhanced index.",
          "signature": "(index_path, file_path, project_root)",
          "called_by": [
            "main"
          ]
        },
        "main": {
          "doc": "Process PostToolUse hook input and update index.",
          "calls": [
            "update_file_in_index"
          ],
          "signature": "()"
        }
      },
      "classes": {},
      "call_graph": {}
    },
    "test_index_creation.sh": {
      "language": "shell",
      "parsed": false,
      "purpose": "Test file"
    },
    "uninstall.sh": {
      "language": "shell",
      "parsed": false
    }
  },
  "dependency_graph": {
    "scripts/detect_external_changes.py": [
      "os",
      "json",
      "pathlib",
      "datetime",
      "subprocess",
      "sys"
    ],
    "scripts/index_aware_hook.py": [
      "json",
      "sys",
      "os",
      "re",
      "subprocess",
      "hashlib",
      "time",
      "pathlib",
      "datetime",
      "base64",
      "pyperclip"
    ],
    "scripts/index_utils.py": [
      "re",
      "fnmatch",
      "pathlib",
      "typing",
      "subprocess"
    ],
    "scripts/project_index.py": [
      "json",
      "os",
      "re",
      "datetime",
      "pathlib",
      "typing",
      "index_utils",
      "index_utils",
      "sys"
    ],
    "scripts/reindex_if_needed.py": [
      "json",
      "sys",
      "os",
      "subprocess",
      "pathlib",
      "datetime"
    ],
    "scripts/update_index.py": [
      "json",
      "sys",
      "os",
      "pathlib",
      "datetime",
      "index_utils"
    ]
  },
  "staleness_check": 1755027383.749804,
  "_meta": {
    "target_size_k": 50,
    "generated_at": 1755632183.7539313,
    "actual_size_k": 4,
    "files_hash": "044a99d5c1ed399f",
    "compression_ratio": "8.0%"
  }
}
